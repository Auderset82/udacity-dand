# Developing Data Scientists: Exploring Free Code Camp's ["2016 New Coder Survey"](https://www.kaggle.com/freecodecamp/2016-new-coder-survey-)
#### By [David Venturi](http://davidventuri.com/)

------

```{r global_options, include=FALSE}
# Set global options
knitr::opts_chunk$set(echo=FALSE, warning=FALSE, message=FALSE)
```

```{r packages}
# Load packages ---------------------------
library(ggplot2)
library(countrycode)
library(plyr)
library(dplyr)
library(ggthemes)
library(scales)
library(grid)
library(gridExtra)
library(extrafont)
library(extrafontdb)
library(tidyr)
library(stringr)
library(psych)
```

```{r Load_Clean_the_Data}
# Load data ---------------------------
setwd('~/Documents/CS/DAND/udacity-dand/p4')
fcc <- read.csv('2016-FCC-New-Coders-Survey-Data.csv')

# Create new continent variables and move them to their alphabetical position
fcc$ContinentCitizen <- countrycode(fcc$CountryCitizen,
                                    'country.name', 'continent')
fcc$ContinentLive <- countrycode(fcc$CountryLive, 'country.name', 'continent')
fcc <- select(fcc, Age:CountryCitizen, ContinentCitizen, CountryLive,
              ContinentLive, EmploymentField:StudentDebtOwe)

# Clean data ---------------------------

# 66 countries with no assigned continent via countrycode()
cit_live_cols <- select(fcc, CountryCitizen:ContinentLive)
problem_countries <- with(cit_live_cols,
                          cit_live_cols[(!is.na(CountryCitizen) &
                                         is.na(ContinentCitizen)) |
                                        (!is.na(CountryLive) &
                                         is.na(ContinentLive)), ])

# Problem country/continent names
fix_cont <- c('Africa', 'Asia', 'Europe', 'Europe', 'Europe', 'Oceania')
names(fix_cont) <- c('Nambia', 'Taiwan', 'Canary Islands', 'Kosovo',
                     'Channel Islands', 'Hawaii')
# Hawaii is generally included in Oceania, even though it is a part of the
# United States (http://cs.mcgill.ca/~rwest/wikispeedia/wpcd/wp/o/Oceania.htm)

# Assign continents to problem countries
fcc$ContinentCitizen <- ifelse(fcc$CountryCitizen %in% names(fix_cont),
                               fix_cont[as.character(fcc$CountryCitizen)],
                               fcc$ContinentCitizen)
fcc$ContinentLive <- ifelse(fcc$CountryLive %in% names(fix_cont),
                            fix_cont[as.character(fcc$CountryLive)],
                            fcc$ContinentLive)

# South American countries in dataset
s_america <- c('Argentina', 'Bolivia', 'Brazil', 'Chile', 'Colombia',
               'Ecuador', 'Guyana', 'Netherland Antilles', 'Paraguay', 'Peru',
               'Uruguay', 'Venezuela')

# Separate Americas into North and South
make_s_america <- function(continent, country) {
  return(ifelse(continent == 'Americas' & country %in% s_america,
                'South America',
                continent))
}

make_n_america <- function(continent, country) {
  return(ifelse(continent == 'Americas' & !(country %in% s_america),
                'North America',
                continent))
}

fcc$ContinentCitizen <- make_s_america(fcc$ContinentCitizen, fcc$CountryCitizen)
fcc$ContinentCitizen <- make_n_america(fcc$ContinentCitizen, fcc$CountryCitizen)
fcc$ContinentLive <- make_s_america(fcc$ContinentLive, fcc$CountryLive)
fcc$ContinentLive <- make_n_america(fcc$ContinentLive, fcc$CountryLive)

# TEST CONTINENT VARS
# table(fcc$ContinentLive)
# table(fcc$ContinentCitizen)

# Make continents factor variables
fcc$ContinentCitizen <- factor(fcc$ContinentCitizen)
fcc$ContinentLive <- factor(fcc$ContinentLive)

# Fix Netherlands (Country...)
fcc$CountryCitizen <- ifelse(fcc$CountryCitizen == "Netherlands (Holland, Europe)",
                             "Netherlands",
                             as.character(fcc$CountryCitizen))
fcc$CountryLive <- ifelse(fcc$CountryLive == "Netherlands (Holland, Europe)",
                          "Netherlands",
                          as.character(fcc$CountryLive))
fcc$CountryCitizen <- factor(fcc$CountryCitizen)
fcc$CountryLive <- factor(fcc$CountryLive)

# Fix Math/Mathematics (SchoolMajor)
fcc$SchoolMajor <- ifelse(fcc$SchoolMajor == "Math",
                          "Mathematics",
                          as.character(fcc$SchoolMajor))
fcc$SchoolMajor <- factor(fcc$SchoolMajor)

# Change 0 to No, 1 to Yes for two plots
fcc$JobRelocateYesNo <- factor(fcc$JobRelocateYesNo)
fcc$JobRelocateYesNo <- revalue(fcc$JobRelocateYesNo,
                                c("0" = "No", "1" = "Yes"))
fcc$IsEthnicMinority <- factor(fcc$IsEthnicMinority)
fcc$IsEthnicMinority <- revalue(fcc$IsEthnicMinority,
                                c("0" = "No", "1" = "Yes"))

# Add three data science podcast columns
fcc$PodcastPartiallyDerivative <-
  with(fcc, ifelse(PodcastOther == "Partially Derivative" |
                   PodcastOther == "http://www.partiallyderivative.com/",
                   as.integer(1),
                   NA))
fcc$PodcastBecomingDataSci <-
  with(fcc, ifelse(PodcastOther == "Becoming A Data Scientist" |
                   PodcastOther == "Learning to be a Data Scientist",
                   as.integer(1),
                   NA))
fcc$PodcastTalkingMachines <-
  with(fcc, ifelse(PodcastOther == "Talking machines",
                   as.integer(1),
                   NA))
fcc <- select(fcc, Age:PodcastOther,
                   PodcastPartiallyDerivative:PodcastTalkingMachines,
                   PodcastProgrammingThrowDown:StudentDebtOwe)

# Cut the HoursLearning variable into buckets
fcc$HoursLearningBucket <-
  cut(fcc$HoursLearning, breaks = c(0, 10, 20, 40, 80))

# Change "NA" to "other" for EmploymentStatus if respondent provided EmploymentStatusOther
fcc$EmploymentStatus <- as.character(fcc$EmploymentStatus)
fcc$EmploymentStatus <-
  with(fcc, ifelse(is.na(EmploymentStatus) & !is.na(EmploymentStatusOther),
                   'Other',
                   EmploymentStatus))
fcc$EmploymentStatus <- as.factor(fcc$EmploymentStatus)

# Change "NA" to "other" for EmploymentField if respondent provided EmploymentFieldOther
fcc$EmploymentField <- as.character(fcc$EmploymentField)
fcc$EmploymentField <-
  with(fcc, ifelse(is.na(EmploymentField) & !is.na(EmploymentFieldOther),
                   'other',
                   EmploymentField))
fcc$EmploymentField <- as.factor(fcc$EmploymentField)
```

## Structure of Dataset
The original ["2016 New Coder Survey"](https://www.kaggle.com/freecodecamp/2016-new-coder-survey-) dataset consists of 113 variables. Most of these variables are answers to survey questions, though a few are computer-generated (e.g. respondent ID and survey start/end times). **Over 15,000 observations** (i.e. respondents) exist.

The [```str``` function](http://www.r-bloggers.com/str-implementation-for-data-frames/) output is long and messy, so I won't print it here. Please consult Free Code Camp's [list of survey questions and possible answers](https://github.com/FreeCodeCamp/2016-new-coder-survey/blob/master/survey-data-dictionary.md). Boolean, numeric, and categorical types are the majority.

## New Variables
I created six new variables from existing variables:

- *ContinentCitizen* and *ContinentLive* from *CountryCitizen* and *CountryLive* using Vincent Arel-Bundock's [countrycode](https://github.com/vincentarelbundock/countrycode) R package
- *PodcastPartiallyDerivative*, *PodcastBecomingDataSci*, and *PodcastTalkingMachines* from *PodcastOther* using [```ifelse``` statements](http://www.programiz.com/r-programming/ifelse-function)
- *HoursLearningBucket* using the [```cut``` function](https://stat.ethz.ch/R-manual/R-devel/library/base/html/cut.html) on *HoursLearning*

These new variables bring our total to **119 variables**.

```{r Full_Dataset}
dim(fcc)
```

## Data Science/Engineering Subset
646 respondents answered "*Data Scientist/Data Engineer*" to the question: "*Which one of these roles are you most interested in?*"

```{r Univariate_Plot_Functions}
# Order factor based on the survey's data science subset results
order_factor <- function(fcc_data_var, desc) {
  var_table <- table(fcc_data_var)
  if (missing(desc)) {
    var_levels <- names(var_table)[order(var_table)]
  }  
  else {
    var_levels <- names(var_table)[order(var_table, decreasing = TRUE)]
  }
  return(factor(fcc_data_var, levels = var_levels))
}

# Text grob for plot titles
plot_title <- function(question) {
  title.grob <- textGrob(
    label = question,
    x = unit(0.3, "lines"), 
    y = unit(-0.3, "lines"),
    hjust = 0, vjust = 0,
    gp = gpar(fontsize = 12, col="#454545"))
  return(title.grob)
}

# Pretty histogram
nice_histogram <- function(col, bw, xlab) {
  df <- as.data.frame(col)
  colnames(df)[1] <- "x"
  
  df_na_rm <- as.data.frame(with(df, df[!is.na(x), ]))
  colnames(df_na_rm)[1] <- "x"
  
  plot <- ggplot(aes(x), data = df_na_rm) +
    geom_histogram(binwidth = bw, color = '#377bb5', fill = '#377bb5') +
    theme_minimal() +
    labs(title = "", x = paste("\n",xlab), y = "Count\n") +
    theme(axis.text = element_text(size=10, color="#454545"),
          axis.title = element_text(color="#454545"))
  return(plot)
}

# Pretty bar chart
nice_bar_plot <- function(col, question, lab_size, lab_cut, num_answers) {
  df <- as.data.frame(col)
  colnames(df)[1] <- "x"
  
  df_na_rm <- as.data.frame(with(df, df[!is.na(x), ]))
  colnames(df_na_rm)[1] <- "x"
  
  if (missing(num_answers)) {
    num_answers <- nrow(df_na_rm)
  }
  
  title.grob <- plot_title(question)
  
  dfTab <- as.data.frame(table(df_na_rm))
  colnames(dfTab)[1] <- "x"
  
  dfTab$lab <- 100 * dfTab$Freq / num_answers
  dfTab$lab <- ifelse(dfTab$lab >= lab_cut, sprintf("%1.1f%%", dfTab$lab), "")
  dfTab$lab <- as.character(dfTab$lab)
  
  plot <- ggplot(df_na_rm) +
    geom_bar(aes(x, alpha = factor(..count..)), fill = "#377bb5") +
    theme_minimal() +
    scale_x_discrete(drop = FALSE) +
    labs(title = "", x = NULL) +
    theme(axis.text = element_text(size=10, color="#454545"),
          axis.title.y = element_text(color = "#454545"),
          legend.position = "none",
          axis.title.x = element_text(margin = margin(15, 0, 9, 0))) +
    geom_text(data = dfTab, aes(x = x, y = Freq, label = lab), hjust = 1,
              color = "white", size = lab_size, fontface = 2) +
    coord_flip()
  
  if (question != "Which one of these roles are you most interested in?") {
    plot <- plot +
            labs(y=paste(as.character(num_answers),
                 "out of 646 developing data scientists/engineers answered")) +
            theme(axis.title.x = element_text(colour = "#377bb5", size = 10))
  }
  else {
    plot <- plot +
            labs(y="Count") +
            theme(axis.title = element_text(color="#454545"))
  }
  
  plot <- arrangeGrob(plot, top = title.grob)
  return(plot)
}
```

```{r Data_Science_Dataset}
# "Which one of these roles are you most interested in?"
fcc_data <-
  with(fcc, fcc[JobRoleInterest == '  Data Scientist / Data Engineer' &
                !is.na(JobRoleInterest), ])

dim(fcc_data)

fcc$JobRoleInterest <- order_factor(fcc$JobRoleInterest)
g_job_int <-
  grid.arrange(nice_bar_plot(fcc$JobRoleInterest,
                             "Which one of these roles are you most interested in?",
                             6, 9))
```

#### <span style="color:#377bb5">The following analysis first explores the characteristics of these developing data scientists/engineers, then dives deeper into the characteristics of new coders in general.</span>
Additional comments are included where the results significantly differ from the full new coder survey dataset.

The univariate section intentionally mimics the structure of [Free Code Camp's Medium article](https://medium.freecodecamp.com/we-asked-15-000-people-who-they-are-and-how-theyre-learning-to-code-4104e29b2781#.dbl4sh7q8) for a direct comparison of data science/engineering students and new coders in general. A few additional univariate plots are included to smooth the transition to the plots explored in the bivariate and multivariate sections.

------

## Univariate Plots

### Who Participated
CodeNewbie and Free Code Camp designed the survey, and dozens of coding-related organizations publicized it to their members.

Of the 646 *developing data scientists and data engineers* who responded to the survey:

#### <span style="color:#377bb5">A quarter are women.</span>

```{r Gender}
# Gender
table(fcc_data$Gender)['female'] / sum(table(fcc_data$Gender))
fcc_data$Gender <- order_factor(fcc_data$Gender)
g_gender <-
  grid.arrange(nice_bar_plot(fcc_data$Gender, "What is your gender?", 11, 1))
# ggsave(file="Gender.png", g_gender)
```

#### <span style="color:#377bb5">Their median age is 26.</span>

```{r Age}
# Age
summary(fcc_data$Age, na.rm = TRUE)
age.grob <- plot_title("How old are you?")
g_age <-
  grid.arrange(nice_histogram(fcc_data$Age, 1, "Age"), top = age.grob)
```

#### <span style="color:#377bb5">They started programming an average of 16 months ago.</span>
This average is 5 months longer than the full survey dataset.

```{r MonthsProgramming}
# MonthsProgramming
summary(fcc_data$MonthsProgramming, na.rm = TRUE)
months_prog.grob <- plot_title("About how many years have you been programming for?")
g_months_prog <-
  grid.arrange(nice_histogram(fcc_data$MonthsProgramming / 12, 0.5,
                              "Years Programming"),
               top = months_prog.grob)
# ggsave(file="MonthsProgramming.png", g_months_prog)
```

The median programming experience of 8 months is much clearer after logarithmically transforming the long tail data.

```{r MonthsProgrammingLog10}
# Add 3/5 of a month to ease log10(0)=-inf issue
# Didn't include grob code in function to permit adding scale_x_log10
g_months_prog_log10 <-
  grid.arrange(nice_histogram((fcc_data$MonthsProgramming + 0.6) / 12, 0.25,
                              "Years Programming") +
               scale_x_log10(breaks = c(0.1, 0.5, 1, 2.5, 5, 10, 25, 50)),
               top = months_prog.grob)
# ggsave(file="MonthsProgrammingLog10.png", g_months_prog_log10)
```

### Learner Goals and Approaches
#### <span style="color:#377bb5">The average respondent dedicates 14 hours per week to learning.</span>

```{r HoursLearning}
# HoursLearning
summary(fcc_data$HoursLearning, na.rm = TRUE)
hours_learn.grob <-
  plot_title("About how many hours do you spend learning each week?")
g_hours_learn <-
  grid.arrange(nice_histogram(fcc_data$HoursLearning, 5, "HoursLearning"),
               top = hours_learn.grob)
# ggsave(file="HoursLearning.png", g_hours_learn)
```


#### <span style="color:#377bb5">No respondents want to freelance or start their own business.</span>
Compared to 40% for the full new coder survey, this is a bit shocking. I understand the demand for data scientists and engineers in industry, but I have a hunch these zero counts are caused by the [survey's design](https://medium.freecodecamp.com/we-just-launched-the-biggest-ever-survey-of-people-learning-to-code-cac81dadf1ea#.4q6h3rxv9). Every respondent that answered the job role of interest question has zero counts for "start your own business" and "freelance."

```{r JobPref}
# JobPref
fcc_data$JobPref <- order_factor(fcc_data$JobPref)
g_job_pref <-
  grid.arrange(nice_bar_plot(fcc_data$JobPref, "Would you prefer to...",
                             11, 0))
# ggsave(file="JobPref.png", g_job_pref)
```

#### <span style="color:#377bb5">52% percent are already applying for jobs, or will start applying within the next year.</span>
The data-related subset has a longer time horizon than the full survey dataset, where 65% are applying within the next year.

```{r JobApplyWhen}
# JobApplyWhen
fcc_data$JobApplyWhen <- order_factor(fcc_data$JobApplyWhen)
g_job_apply_when <-
  grid.arrange(nice_bar_plot(fcc_data$JobApplyWhen,
                             "When do you plan to start applying for jobs?",
                             11, 0))
# ggsave(file="JobApplyWhen.png", g_job_apply_when)
```

#### <span style="color:#377bb5">Most of them want to work in an office, as opposed to remotely.</span>

```{r JobWherePref}
# JobWherePref
fcc_data$JobWherePref <- order_factor(fcc_data$JobWherePref)
g_job_where_pref <-
  grid.arrange(nice_bar_plot(fcc_data$JobWherePref,
                             "Would you prefer to work...", 11, 0))
# ggsave(file="JobWherePref.png", g_job_where_pref)
```

#### <span style="color:#377bb5">And a majority are willing to relocate.</span>

```{r JobRelocateYesNo}
# JobRelocateYesNo
fcc_data$JobRelocateYesNo <- order_factor(fcc_data$JobRelocateYesNo)
g_job_relo <-
  grid.arrange(nice_bar_plot(fcc_data$JobRelocateYesNo,
                             "Are you willing to relocate for a job?",
                             12.3, 0))
# ggsave(file="JobRelocateYesNo.png", g_job_relo)
```

#### <span style="color:#377bb5">Most of them have not yet attended any in-person coding events.</span>

```{r CodeEvent}
# LEARN TO USE LAZYEVAL TO MAKE A FUNCTION FOR THE NEXT THREE WRANGLING SEQUENCES (CodeEvent, Resource, Podcast) IN THE FUTURE

# CodeEvent
code_event_cols <- select(fcc_data, CodeEventBootcamp:CodeEventWorkshop)
code_event_cols$CodeEventOther <-
  ifelse(!is.na(code_event_cols$CodeEventOther),
         as.integer(1),
         NA)
code_event_cols$answered <-
  ifelse(rowSums(code_event_cols, na.rm = TRUE) != 0,
         1,
         0)
num_answers_code_event <- sum(code_event_cols[ , 'answered'])
code_event_sum <-
  code_event_cols %>%
  summarise_each(funs(sum(., na.rm = TRUE)))
code_event_sum_long <-
  gather(code_event_sum, event, num_yes, CodeEventBootcamp:CodeEventWorkshop) %>%
  arrange(desc(num_yes)) %>%
  mutate(event = str_sub(event, nchar("CodeEvent") + 1, -1))
code_event_factor <- as.data.frame(rep(code_event_sum_long$event,
                                       code_event_sum_long$num_yes))
colnames(code_event_factor) <- "event"
code_event_factor$event <- order_factor(code_event_factor$event)
code_event_factor_lim <-
  code_event_factor %>%
  group_by(event) %>%
  filter(n() > 2)
g_code_event <-
  grid.arrange(nice_bar_plot(droplevels(code_event_factor_lim$event),
                             "Which types of in-person coding events have you attended?",
                             5.7, 5, num_answers_code_event))
# ggsave(file="CodeEvent.png", g_code_event)
```

#### <span style="color:#377bb5">On average, they use at least three different resources for learning.</span>
The developing data scientists/engineers use Coursera, edX, and Udacity more frequently than new coders in general. These companies have wider subject area scopes than the some of the coding-specific resources listed.

```{r Resource}
# Resource
# length(resource_factor$resource) / dim(fcc_data)[1]
# 3.543344
resource_cols <- select(fcc_data, ResourceBlogs:ResourceYouTube)
resource_cols$ResourceOther <- ifelse(!is.na(resource_cols$ResourceOther),
                                      as.integer(1),
                                      NA)
resource_cols$answered <- ifelse(rowSums(resource_cols, na.rm = TRUE) != 0,
                                 1,
                                 0)
num_answers_resource <- sum(resource_cols[ , 'answered'])
resource_sum <-
  resource_cols %>%
  summarise_each(funs(sum(., na.rm = TRUE)))
resource_sum_long <-
  gather(resource_sum, resource, num_yes, ResourceBlogs:ResourceYouTube) %>%
  arrange(desc(num_yes)) %>%
  mutate(resource = str_sub(resource, nchar("Resource") + 1, -1))
resource_factor <- as.data.frame(rep(resource_sum_long$resource,
                                       resource_sum_long$num_yes))
colnames(resource_factor) <- "resource"
resource_factor$resource <- order_factor(resource_factor$resource)
resource_factor_lim <-
  resource_factor %>%
  group_by(resource) %>%
  filter(n() > 4)
g_resource <-
  grid.arrange(nice_bar_plot(droplevels(resource_factor_lim$resource),
                             "Which learning resources have you found helpful?",
                             4.3, 5, num_answers_resource))
# ggsave(file="Resource.png", g_resource)
```

#### <span style="color:#377bb5">Less than 20% listen to coding-related podcasts.</span>
Of them, Partially Derivative, Becoming A Data Scientist, and Talking Machines are the only data-specific podcasts noted.

```{r Podcast}
# Podcast
podcast_cols <- select(fcc_data, PodcastChangeLog:PodcastWebAhead)
# Convert podcast answer to boolean
podcast_cols$PodcastOther <- ifelse(!is.na(podcast_cols$PodcastOther),
                                    as.integer(1),
                                    NA)
# If row is empty, the respondent didn't answer the podcast question
podcast_cols$answered <- ifelse(rowSums(podcast_cols, na.rm = TRUE) != 0,
                                1,
                                0)
num_answers_podcast <- sum(podcast_cols[ , 'answered'])
# Wide format
podcast_sum <-
  podcast_cols %>%
  summarise_each(funs(sum(., na.rm = TRUE)))
# Long format
podcast_sum_long <-
  gather(podcast_sum, podcast, num_yes, PodcastChangeLog:PodcastWebAhead) %>%
  arrange(desc(num_yes)) %>%
  mutate(podcast = str_sub(podcast, nchar("Podcast") + 1, -1))
# Factor format
podcast_factor <- as.data.frame(rep(podcast_sum_long$podcast,
                                       podcast_sum_long$num_yes))
colnames(podcast_factor) <- "podcast"
podcast_factor$podcast <- order_factor(podcast_factor$podcast)
g_podcast <-
  grid.arrange(nice_bar_plot(podcast_factor$podcast,
                             "Which coding-related podcasts have you found helpful?",
                             4.3, 7, num_answers_podcast))
# ggsave(file="podcast.png", g_podcast)
```

#### <span style="color:#377bb5">Only 1% have attended a bootcamp.</span>
6% of new coders from the full survey dataset have attended a bootcamp.

```{r Bootcamp}
# Bootcamp
fcc_data$BootcampName <- order_factor(fcc_data$BootcampName)
g_bootcamp_name <-
  grid.arrange(nice_bar_plot(droplevels(fcc_data$BootcampName),
                             "If you have attended a full-time coding bootcamp, which one?",
                             6, 0))
# ggsave(file="BootcampName.png", g_bootcamp_name)
```

### Demographics and Socioeconomics
#### <span style="color:#377bb5">Data-focused respondents represent 166 countries.</span>

```{r Country}
# CountryCitizen
# length(names(table(fcc_data$CountryCitizen)))
# 166
fcc_data$CountryCitizen <- order_factor(fcc_data$CountryCitizen)
country_citizen_na_rm <- with(fcc_data, fcc_data[!is.na(CountryCitizen), ])
country_citizen_na_rm_lim <-
  country_citizen_na_rm %>%
  group_by(CountryCitizen) %>%
  filter(n() > 4)
g_country_citizen <-
  grid.arrange(nice_bar_plot(droplevels(country_citizen_na_rm_lim$CountryCitizen),
                             "Which country are you a citizen of?", 3.2, 3,
                             nrow(country_citizen_na_rm)))
# ggsave(file="CountryCitizen.png", g_country_citizen)
```

#### <span style="color:#377bb5">More than 90% are from North America, Europe, and Asia.</span>
The dominating percentage of North Americans should be expected because Free Code Camp is based in the United States.

```{r Continent}
# ContinentCitizen
fcc_data$ContinentCitizen <- order_factor(fcc_data$ContinentCitizen)
g_continent_citizen <-
  grid.arrange(nice_bar_plot(droplevels(fcc_data$ContinentCitizen),
                             "Which continent are you a citizen of?", 9, 4))
# ggsave(file="ContinentCitizen.png", g_continent_citizen)
```

#### <span style="color:#377bb5">Their cities span a wide range of urbanization levels.</span>

```{r CityPopulation}
# CityPopulation
fcc_data$CityPopulation <- order_factor(fcc_data$CityPopulation)
g_city_pop <-
  grid.arrange(nice_bar_plot(fcc_data$CityPopulation,
                             "About how many people live in your city?",
                             11, 0))
# ggsave(file="CityPopulation.png", g_city_pop)
```

#### <span style="color:#377bb5">Just under a quarter of respondents are ethnic minorities in their country.</span>

```{r IsEthnicMinority}
# Ethnic Minority
fcc_data$IsEthnicMinority <- order_factor(fcc_data$IsEthnicMinority)
g_ethnic_minority <-
  grid.arrange(nice_bar_plot(fcc_data$IsEthnicMinority,
                             "Are you an ethnic minority in your country?",
                             13, 0))
# ggsave(file="IsEthnicMinority.png", g_ethnic_minority)
```

#### <span style="color:#377bb5">And nearly half are non-native English speakers. They grew up speaking one of 148 languages.</span>

```{r LanguageAtHome}
# LanguageAtHome
# length(names(table(fcc_data$LanguageAtHome)))
# 148
fcc_data$LanguageAtHome <- order_factor(fcc_data$LanguageAtHome)
language_na_rm <- with(fcc_data, fcc_data[!is.na(LanguageAtHome), ])
language_na_rm_lim <-
  language_na_rm %>% group_by(LanguageAtHome) %>%
  filter(n() > 5)
g_language <-
  grid.arrange(nice_bar_plot(droplevels(language_na_rm_lim$LanguageAtHome),
                             "Which language do you speak at home with your family?",
                             3.6, 3.6, nrow(language_na_rm)))
# ggsave(file="LanguageAtHome.png", g_language)
```

#### <span style="color:#377bb5">67% have earned at least a bachelor’s degree.</span>
Compared to 58% for the full new coder survey, the data-focused subset is more skewed towards post-secondary studies.

```{r SchoolDegree}
# SchoolDegree
fcc_data$SchoolDegree <- order_factor(fcc_data$SchoolDegree)
g_school_degree <-
  grid.arrange(nice_bar_plot(fcc_data$SchoolDegree,
                             "What is the highest level of school you have completed?",
                             5.7, 5))
# ggsave(file="SchoolDegree.png", g_school_degree)
```

#### <span style="color:#377bb5">They studied 425 different majors. Computer Science and Mathematics were the two most popular majors, and an additional 16% studied some form of engineering.</span>
Diversity amongst majors is greater compared to the full survey, where Computer Science and Information Technology checked in at #1 and #2 with 17% and 5%, respectively.

```{r SchoolMajor}
# SchoolMajor
# length(names(table(fcc_data$SchoolMajor)))
# 425
fcc_data$SchoolMajor <- order_factor(fcc_data$SchoolMajor)
school_major_na_rm <- with(fcc_data, fcc_data[!is.na(SchoolMajor), ])
school_major_na_rm_lim <-
  school_major_na_rm %>%
  group_by(SchoolMajor) %>%
  filter(n() > 5)
g_school_major <-
  grid.arrange(nice_bar_plot(droplevels(school_major_na_rm_lim$SchoolMajor),
                             "What was the main subject you studied in university?",
                             3, 0, nrow(school_major_na_rm)))
# ggsave(file="SchoolMajor.png", g_school_major)
```

#### <span style="color:#377bb5">Just over one-half are currently working.</span>
Two-thirds of new coders, in general, are currently working.

```{r EmploymentStatus}
# EmploymentStatus
fcc_data$EmploymentStatus <- order_factor(fcc_data$EmploymentStatus)
g_employment_status <-
  grid.arrange(nice_bar_plot(fcc_data$EmploymentStatus,
                             "Regarding employment status, are you currently...",
                             5.7, 8))
# ggsave(file="EmploymentStatus.png", g_employment_status)
```

#### <span style="color:#377bb5">A quarter work in the tech industry.</span>
Employment fields are more spread compared to the full new coder survey, where 50% of respondents work in software development and IT.

```{r EmploymentField}
# EmploymentField
fcc_data$EmploymentField <- order_factor(fcc_data$EmploymentField)
g_employment_field <-
  grid.arrange(nice_bar_plot(droplevels(fcc_data$EmploymentField),
                             "Which field do you work in?", 4, 2))
# ggsave(file="EmploymentField.png", g_employment_field)
```

#### <span style="color:#377bb5">Median current salary is $44k.</span>
The median current salary for the full dataset is $37k.

```{r Income}
# Income
summary(fcc_data$Income, na.rm = TRUE)
income.grob <- plot_title("What is your current salary in USD?")
g_income <-
  grid.arrange(nice_histogram(fcc_data$Income, 10000, "Income"),
               top = income.grob)
# ggsave(file="Income.png", g_income)
```

#### <span style="color:#377bb5">And they expect to earn a median of $60k with their new data science/engineering skills.</span>
The median for the full survey dataset is $50k. With data science/engineering being [notoriously lucrative](http://www.wired.com/insights/2015/03/data-scientists-earning-salaries/) in 2016, some respondents might be seeking higher wages.

```{r ExpectedEarning}
# ExpectedEarning
summary(fcc_data$ExpectedEarning, na.rm = TRUE)
exp_earn.grob <-
  plot_title("About how much do you expect to earn per year at your first new job in USD?")
g_exp_earn <-
  grid.arrange(nice_histogram(fcc_data$ExpectedEarning, 10000, "ExpectedEarning"),
               top = exp_earn.grob)
# ggsave(file="ExpectedEarning.png", g_exp_earn)
```

#### <span style="color:#377bb5">7% have served in their country’s military.</span>

```{r HasServedInMilitary}
# HasServedInMilitary
has_served <- table(fcc_data$HasServedInMilitary)['1']
names(has_served) = c("has served in military")
has_served / nrow(fcc_data)
```

#### <span style="color:#377bb5">13% have children, and another 3% financially support an elderly or disabled relative. And one-fifth are doing this without the help of a spouse.</span>

```{r Home_Life}
# HasChildren
has_children <- table(fcc_data$HasChildren)['1']
names(has_children) = c("has children")
has_children / nrow(fcc_data)

# FinanciallySupporting
fin_supporting <- table(fcc_data$FinanciallySupporting)['1']
names(fin_supporting) = c("financially supporting")
fin_supporting / nrow(fcc_data)

# MaritalStatus
no_spouse <- (table(fcc_data$MaritalStatus)['widowed'] +
  table(fcc_data$MaritalStatus)['single, never married'] +
  table(fcc_data$MaritalStatus)['divorced'] +
  table(fcc_data$MaritalStatus)['separated'])
names(no_spouse) = c("no spouse")
no_spouse / sum(table(fcc_data$MaritalStatus))
```

#### <span style="color:#377bb5">47% consider themselves underemployed (working a job that is below their education level).</span>

```{r IsUnderEmployed}
# IsUnderEmployed
is_under_emp <- table(fcc_data$IsUnderEmployed)['1']
names(is_under_emp) = c("is underemployed")
is_under_emp / sum(table(fcc_data$IsUnderEmployed))
```

#### <span style="color:#377bb5">If they have a home mortgage, they owe an average of $194k.</span>

```{r HomeMortgageOwe}
# HomeMortgageOwe
summary(fcc_data$HomeMortgageOwe, na.rm = TRUE)
home_mort_owe.grob <-
  plot_title("About how much do you owe on your home mortgage in USD?")
g_home_mort_owe <-
  grid.arrange(nice_histogram(fcc_data$HomeMortgageOwe, 100000, "HomeMortgageOwe"),
               top = home_mort_owe.grob)
```

#### <span style="color:#377bb5">If they have student loans, they owe an average of $37k.</span>
This average is $3k more than the full survey dataset.

```{r StudentDebtOwe_1}
# StudentDebtOwe
summary(fcc_data$StudentDebtOwe, na.rm = TRUE)
stud_debt_owe.grob <-
  plot_title("About how much do you owe in student debt loans in USD?")
g_stud_debt_owe <-
  grid.arrange(nice_histogram(fcc_data$StudentDebtOwe, 10000, "StudentDebtOwe"),
               top = stud_debt_owe.grob)
```

Removing the million dollar outlier, the distribution is much clearer with the majority of debt under $75k. I hope that outlier is a joke.

```{r StudentDebtOwe_2}
# StudentDebtOwe without 1 million outlier (joke?)
stud_debt_owe.grob <-
  plot_title("About how much do you owe in student debt loans in USD?")
stud_debt_owe_mil_rm <- with(fcc_data, fcc_data[StudentDebtOwe < 1000000, ])
g_stud_debt_owe <-
  grid.arrange(nice_histogram(stud_debt_owe_mil_rm$StudentDebtOwe, 10000, "StudentDebtOwe"),
               top = stud_debt_owe.grob)
```

#### <span style="color:#377bb5">14% don’t yet have high-speed internet at home.</span>

```{r HasHighSpdInternet}
# HasHighSpdInternet
has_hs_int <- table(fcc_data$HasHighSpdInternet)['1']
names(has_hs_int) = c("has high-speed internet")
has_hs_int / sum(table(fcc_data$HasHighSpdInternet))
```

#### <span style="color:#377bb5">And 3% are currently receiving disability benefits from their government.</span>

```{r IsReceiveDiabilitiesBenefits}
# IsReceiveDiabilitiesBenefits
disability_bfts <- table(fcc_data$IsReceiveDiabilitiesBenefits)['1']
names(disability_bfts) = c("is receiving disability benefits")
disability_bfts / sum(table(fcc_data$IsReceiveDiabilitiesBenefits))
```

## Univariate Analysis

### What is/are the main feature(s) of interest in your dataset?

There isn't really a singular main feature of interest in the "2016 New Coder Survey" dataset. There are several smaller features, but nothing stands out like diamond price and its relationship to carat weight, cut, colour, etc. in the [R diamonds dataset](http://docs.ggplot2.org/0.9.3.1/diamonds.html), for example. The diamonds dataset covers two time periods (the existence of the diamond pre-sale and post-sale), whereas the survey dataset only covers a single period (the early stages of an individual's coding career).

If we could fast-forward several years and survey the same respondents, the main feature of interest might be career earnings (adjusted for cost of living, preferably) and/or self-reported career satisfaction. A predictive model using a combination of variables from the 2016 survey could then be built to estimate career success.

If the survey asked "*Are you already working as a data scientist/engineer?*" instead of "*Are you already working as a software developer?*", the current income variable might be a main feature of interest. Unfortunately, the answer to that question cannot be extracted from the existing variables.

### What other features in the dataset do you think will help support your investigation into your feature(s) of interest?

Though there isn't a main feature of interest, we can separate the respondents who did **not** answer "*Data Scientist/Data Engineer*" to the job role interest question (as we already have for those who did) and compare the two subsets using bivariate and multivariate plots.

I will also explore two smaller features, hours dedicated to learning per week and expected next salary, using bivariate and multivariate plots.

### Of the features you investigated, were there any unusual distributions?

There is a lot of long tail data. Most did not require transformation to view the details of the distribution. Programming experience is *really* positively skewed, however, and required log transformation to visually compare those with 3 months experience to those with 25 years.

That no respondents want to freelance or start their own business seems strange. Perhaps a [survey design](https://medium.freecodecamp.com/we-just-launched-the-biggest-ever-survey-of-people-learning-to-code-cac81dadf1ea#.4q6h3rxv9) choice caused these zero counts.

### Did you perform any operations on the data to tidy, adjust, or change the form of the data? If so, why did you do this?

The following operations were performed to tidy, adjust, or change the form of the data:

- Each code event, resource, and podcast is represented by a boolean variable. I summed the number of yeses for each, which created a single row of sums. I used [tidyr](https://github.com/hadley/tidyr)'s ```gather()``` to transform the data from a wide format to a long format. Then I transformed the long data into factor format, using the [replicate function](https://stat.ethz.ch/R-manual/R-devel/library/base/html/rep.html) with the number of yeses as the multiplier. This data is used to create the code event, resource, and podcast bar charts. ![wide to long to factor formats](http://i.imgur.com/ICL9lkQ.png)
- After subselecting all code event, resource, and podcast columns separately, I created a new boolean variable named *answered*, where 1 represents using at least one event/resource/podcast and 0 represents using none. The *answered* sum total is used in the "*x out of 646 developing data scientists/engineers answered*" label at the bottom of each bar chart. ![label](http://i.imgur.com/j04JNl5.png)
- I separated data-specific podcasts in the user-inputted PodcastOther category into their own boolean variables.
- I changed "NA" in the EmploymentStatus variable to "other" if the respondent provided the user-inputted EmploymentStatusOther variable.
- I changed "NA" in the EmploymentField variable to "other" if the respondent provided the user-inputted EmploymentFieldOther variable.
- I separated the “Americas” continents outputted by [countrycode()](https://github.com/vincentarelbundock/countrycode) into North and South America.

The first five operations were performed so bar charts could be created, which wasn't possible with the original data format. The Americas separation was performed for additional insight.

------

## Bivariate Plots

14974 respondents did **not** answer "*Data Scientist/Data Engineer*" to the question: "*Which one of these roles are you most interested in?*"

```{r Non_Data_Science_Dataset}
non_fcc_data <-
  with(fcc, fcc[JobRoleInterest != '  Data Scientist / Data Engineer', ])
dim(non_fcc_data)
```

### SPLOMs

The next two plots are created using [pairs.panels()](http://www.inside-r.org/packages/cran/psych/docs/pairs.panels) from the *psych* package. They display a scatter plot of matrices (SPLOM), with bivariate scatter plots below the diagonal, histograms on the diagonal, and the Pearson correlation above the diagonal.

**For the data science subset of the survey**, all correlations are below 0.4, which supports my statement that no main feature exists. The strongest of the correlations are:

- Age and Income (0.30)
- Income and ExpectedEarning (0.36)
- Income and StudentDebtOwe (0.34)

The phenomena revealed are intuitive, but not groundbreaking: you tend to make more money when you are older, you tend to expect your next job to have a high salary if your current one does, and expensive schooling tends to lead to higher income levels.

```{r Data_Science_Panel}
# SPLOM for data scientist/engineer subset
data_panel <-
  pairs.panels(select(fcc_data, Age, MonthsProgramming, HoursLearning,
                      Income, ExpectedEarning, StudentDebtOwe),
               hist.col = "#377bb5", col = "#FF4541")
```

**For the non-data science subset of the survey**, all correlations are again below 0.4. Most of the correlations are within 0.1 of the data science subset, except for three:

- Age and StudentDebtOwe (0.24 - 0.10 = 0.14)
- MonthsProgramming and StudentDebtOwe (-0.07 - 0.09 = -0.16)
- Income and StudentDebtOwe (0.34 - 0.08 = 0.26)

Interesting. Student debt levels are involved in all three correlations. I bet the aforementioned skew towards post-secondary studies for the data science subset plays a role here, where higher levels of student debt are expected.

```{r Non_Data_Science_Panel}
# SPLOM for non-data scientist/engineer subset
non_data_panel <-
  pairs.panels(select(non_fcc_data, Age, MonthsProgramming, HoursLearning,
                      Income, ExpectedEarning, StudentDebtOwe),
               hist.col = "#377bb5", col = "#FF4541")
```

Let's zoom in on the strong age-income correlation, this time for the full survey dataset. Note that the strength exists despite the majority of $200k salaries belonging to respondents under 40.

```{r Age_Income}
# Pretty scatter plot
nice_scatter <- function(xcol, ycol, xlab, ylab) {
  xdf <- as.data.frame(xcol)
  ydf <- as.data.frame(ycol)
  df <- merge(xdf, ydf, by = 0)
  #df <- df[order(as.numeric(df$Row.names)),]
  
  colnames(df)[2] <- "x"
  colnames(df)[3] <- "y"
  
  df_na_rm <- with(df, df[!is.na(x) & !is.na(y), ])
  
  plot <- ggplot(aes(x = x, y = y), data = df_na_rm) +
  geom_jitter(alpha = 0.50, colour = "#377bb5") +
  geom_smooth(method = 'lm', colour = "#FF4541") +
  theme_minimal() +
  labs(title = "", x = paste("\n", xlab), y = paste(ylab, "\n")) +
  theme(axis.text = element_text(size = 10, color = "#454545"),
        axis.title = element_text(color = "#454545"))
  return(plot)
}

age_income.grob <-
  plot_title("What is your current salary in USD?\nHow old are you?")
r_age_income <-
  paste("r =",
        as.character(round(with(fcc,
                                cor.test(Age, Income, method = 'pearson'))$estimate,
                           digits = 3)))
g_age_income <-
  grid.arrange(nice_scatter(fcc$Age, fcc$Income, "Age", "Income") +
               annotate("text", x = 65, y = 150000, label = r_age_income,
                        colour = "#FF4541"), top = age_income.grob)
```

The earnings vs. age trend, however, isn't maintained as these individuals prepare to transition to their new field of choice. Younger individuals appear willing to capitalize on lucrative tech salaries and older individuals appear willing to take a pay cut.

```{r Age_Exp_Earn}
age_exp_earn.grob <-
  plot_title("About how much do you expect to earn per year at your first new job in USD?\nHow old are you?")
r_age_exp_earn <-
  paste("r =",
        as.character(round(with(fcc,
                                cor.test(Age, ExpectedEarning, method = 'pearson'))$estimate,
                           digits = 3)))
g_age_income <-
  grid.arrange(nice_scatter(fcc$Age, fcc$ExpectedEarning,
                            "Age", "ExpectedEarning") +
                 annotate("text", x = 65, y = 112500, label = r_age_exp_earn,
                          colour = "#FF4541"), top = age_exp_earn.grob)
```

### Gender and Citizenship

Let's use the full new coder survey for the rest of the analysis. We'll explore hours dedicated to learning per week and expected next salary. These are variables dependent upon the quality of coding resources, whereas the other numerical ones (e.g. age, income, and programming experience) are set previously.

**For the following [boxplots](http://www.physics.csbsju.edu/stats/box2.html), the horizontal line is the median and the "x" is the mean. The top of the box is the third quartile and the bottom is the first quartile. Whisker length is the interquartile range multiplied by 1.5.**

Hours dedicated to learning results are nearly identical across genders. Do trans new coders spend more time learning? A small sample size issue exists, but I wouldn't be shocked if a true effect is present here.

```{r Hours_Learn_Gender}
# Pretty boxplot
nice_boxplot <- function(df, xlab, ylab, questions, hue) {
  # select()-created df passed in rather than two columns as in nice_scatter
  colnames(df)[1] <- "x"
  colnames(df)[2] <- "y"
  
  df_na_rm <- with(df, df[!is.na(x) & !is.na(y), ])
  colnames(df_na_rm)[1] <- "x"
  colnames(df_na_rm)[2] <- "y"
  
  if (ylab == "ExpectedEarning (k)" | ylab == "StudentDebtOwe (k)") {
    df_na_rm[ , 2] <- df_na_rm[ , 2] / 1000
  }
  
  plot <- ggplot(df_na_rm, aes(x = x, y = y, fill = x)) +
    geom_boxplot(colour = "#454545", outlier.colour = "#454545") +
    theme_minimal() +
    labs(title = "", x = paste("\n", xlab), y = paste(ylab, "\n"), fill = "# of Respondents\n(Descending)") +
    theme(text = element_text(color="#454545"),
          title = element_text(color = "#454545"),
          axis.text = element_text(size=10),
          legend.key.size = unit(1.5, 'lines')) +
    scale_fill_discrete(h = hue) +
    scale_x_discrete(labels = function(x) str_wrap(x, width = 15)) +
    stat_summary(fun.y = mean, geom = "point", colour = "#454545", shape = 4)
  
  title.grob <- plot_title(questions)
  plot <- arrangeGrob(plot, top = title.grob)
  return(plot)
}

# Hours Learning by Gender
fcc$Gender <- order_factor(fcc$Gender, "desc")
g_hours_learn_gender <-
  grid.arrange(nice_boxplot(select(fcc, Gender, HoursLearning),
                            "Gender", "HoursLearning",
                            "About how many hours do you spend learning each week?\nWhat is your gender?",
                            c(0, 30)))
sort(table(fcc$Gender), decreasing = TRUE)
```

<br>
Not much differentiation for continents as well. All have a median of 10 hours dedicated to learning per week. Asian and African students have the highest means, at 16.4 and 16.8 hours, respectively.

```{r Hours_Learn_Continent, fig.width = 8}
# Hours Learning by ContinentCitizen
fcc$ContinentCitizen <- order_factor(fcc$ContinentCitizen, "desc")
g_hours_learn_continent <-
  grid.arrange(nice_boxplot(select(fcc, ContinentCitizen, HoursLearning),
                            "ContinentCitizen", "HoursLearning",
                            "About how many hours do you spend learning each week?\nWhich continent are you a citizen of?",
                            c(240, 270)))
sort(table(fcc$ContinentCitizen), decreasing = TRUE)
```

<br>
Females actually expect higher salaries than males, with a $9k gap in medians and a $4k gap in means. There is a huge gap in first quartiles, where the 25th percentile female expects $14k more than her male equivalent. As with hours dedicated to learning, transgender new coders have relatively higher expected salaries. Did a particularly ambitious set of trans individuals respond to the survey or are these their true traits?

```{r Exp_Earn_Gender}
# Expected Earning by Gender
g_exp_earn_gender <-
  grid.arrange(nice_boxplot(select(fcc, Gender, ExpectedEarning),
                            "Gender", "ExpectedEarning (k)",
                            "About how much do you expect to earn per year at your first new job in USD?\nWhat is your gender?",
                            c(0, 30)))
with(fcc, by(ExpectedEarning, Gender, summary))
```

<br>
Whoa. Expected earning by continent varies way more compared to the above three boxplots. North Americans expect the highest range of salaries, with their interquartile range spanning from $50k to $70k. Europe's 75th percentile is North America's 25th percentile. I wonder if some European respondents forgot to convert from pounds or euros to US dollars. Expectations in Asia are all over the board.

A lot of these individuals are using similar, if not the same, online educational resources. Labour market economics are cruel.

```{r Exp_Earn_Continent, fig.width = 8}
# Expected Earning by ContinentCitizen
g_exp_earn_continent <-
  grid.arrange(nice_boxplot(select(fcc, ContinentCitizen, ExpectedEarning),
                            "ContinentCitizen", "ExpectedEarning (k)",
                            "About how much do you expect to earn per year at your first new job in USD?\nWhich continent are you a citizen of?",
                            c(240, 270)))
with(fcc, by(ExpectedEarning, ContinentCitizen, summary))
```

<br>
The median respondent that dedicates 40+ hours per week expects $10k more than the median respondents from the other brackets.

```{r Exp_Earn_Hours_Learn}
# Expected Earning by Hours Learning
g_exp_earn_hours_learning <-
  grid.arrange(nice_boxplot(select(fcc, HoursLearningBucket,
                                   ExpectedEarning),
                            "HoursLearning", "ExpectedEarning (k)",
                            "About how much do you expect to earn per year at your first new job in USD?\nAbout how many hours do you spend learning each week?",
                            c(115, 195)))
table(fcc$HoursLearningBucket)
```

<br>
Let's dig into that 40-80 hour bracket. Less than 5% of respondents are dedicating 40+ hours to learning each week. Below are the most common ages (the top row is age and the bottom row is number of respondents) and educational backgrounds for this bracket.

```{r Full_Time_New_Coders}
full_time_new_coders <- filter(fcc, HoursLearningBucket == "(40,80]")
sort(table(full_time_new_coders$Age), decreasing = TRUE)[1:10]
sort(table(full_time_new_coders$SchoolDegree), decreasing = TRUE)[1:6]
```

<br>
Most of these respondents are in their early twenties and have a bachelor's degree. It appears that they are forgoing traditional forms of higher education like master's and professional degrees and using those 40+ hour weeks to learn code.

This is the exact situation I'm in with [my personalized data science master's degree](https://medium.com/@venturidb/i-dropped-out-of-school-to-create-my-own-data-science-master-s-here-s-my-curriculum-1b400dcee412#.kl5dis6bb). The quality and affordability of online education in 2016 is incredible, though many still aren't aware of the existence of resources like Free Code Camp, Udacity, and Coursera. If this survey was performed in a few years, I would expect more respondents to be in the higher brackets.

### Job Roles of Interest

Again, the most common job roles of interest are:

```{r Job_Role_Interest}
# JobRole Interest
sort(table(fcc$JobRoleInterest), decreasing = TRUE)
fcc$JobRoleInterest <- order_factor(fcc$JobRoleInterest, "desc")
fcc_job_lim <- with(fcc, fcc[JobRoleInterest != "  DevOps / SysAdmin" &
                             JobRoleInterest != "  Product Manager" &
                             JobRoleInterest != "  Quality Assurance Engineer", ])
fcc_job_lim$JobRoleInterest <- droplevels(fcc_job_lim$JobRoleInterest)

fcc_job_lim$JobRoleInterest <-
  revalue(fcc_job_lim$JobRoleInterest,
          c("Full-Stack Web Developer" = 
            "Full-Stack Developer",
            "  Front-End Web Developer" =
            "Front-End Developer",
            "Back-End Web Developer" =
            "Back-End Developer",
            "  Data Scientist / Data Engineer" =
            "Data Scientist / Engineer",
            "  Mobile Developer" =
            "Mobile Developer",
            "  User Experience Designer" =
            "UX Designer"))
```

<br>
User Experience Designer is by far the most diverse discipline in terms of gender, with about the same amount of males as females and the highest percentage of agender, genderqueer, and trans respondents. Mobile development is the most male-dominated discipline near 80%, though full-stack and back-end development are close.

```{r Gender_Job_Role_Interest, fig.width = 8}
# Pretty segmented bar chart
nice_seg_bar_plot <- function(df, xlab, flab, question, hue) {
  df <- as.data.frame(df)
  colnames(df)[1] <- "x"
  colnames(df)[2] <- "f"
  
  df_na_rm <- as.data.frame(with(df, df[!is.na(x) & !is.na(f), ]))
  colnames(df_na_rm)[1] <- "x"
  colnames(df_na_rm)[2] <- "f"
  
  title.grob <- plot_title(question)
  
  plot <- ggplot(df_na_rm, aes(x = x, fill = f)) + 
    geom_bar(position = "fill") +
    scale_y_continuous(labels = percent_format()) +
    theme_minimal() +
    labs(title = "", x = paste("\n", xlab), y = "Percentage\n", fill = flab) +
    theme(text = element_text(color="#454545"),
          title = element_text(color = "#454545"),
          axis.text = element_text(size=10)) +
    scale_fill_discrete(h = hue) +
    scale_x_discrete(labels = function(x) str_wrap(x, width = 15))
  
  plot <- arrangeGrob(plot, top = title.grob)
  return(plot)
}

# Gender by Job Role Interest
g_gender_job_int <- 
  grid.arrange(nice_seg_bar_plot(select(fcc_job_lim, JobRoleInterest, Gender),
                               "JobRoleInterest", "Gender",
                               "What is your gender?\nWhich one of these roles are you most interested in?",
                               c(290, 650)))
```

The highest relative popularity for North America (read: biggest purple bar segment) is user experience design. Europe's is back-end development. Asia's, South America's, and Africa's is mobile development. Oceania's is data science/engineering. Mobile developer is the most diverse discipline in terms of citizenship.

```{r Continent_Job_Role_Interest, fig.width = 8}
# Continent by Job Role Interest
g_cont_job_int <- 
  grid.arrange(nice_seg_bar_plot(select(fcc_job_lim, JobRoleInterest, ContinentCitizen),
                               "JobRoleInterest", "ContinentCitizen",
                               "Which continent are you a citizen of?\nWhich one of these roles are you most interested in?",
                               c(290, 650)))

# table(filter(fcc_job_lim, JobRoleInterest == "Data Scientist / Engineer")$ContinentCitizen)["Oceania"] / sum(table(filter(fcc_job_lim, JobRoleInterest == "Data Scientist / Engineer")$ContinentCitizen))

# table(filter(fcc_job_lim, JobRoleInterest == "UX Designer")$ContinentCitizen)["Oceania"] / sum(table(filter(fcc_job_lim, JobRoleInterest == "UX Designer")$ContinentCitizen))
```

The skew towards post-secondary studies for data science and data engineering is much clearer here. Mobile development has the highest percentage of respondents with no, some, or only a high school education. This skew will surely reflect itself in the subsequent age boxplot.

```{r Degree_Job_Role_Interest, fig.width = 9}
# School Degree by Job Role Interest
fcc_job_lim$SchoolDegree <-
  factor(fcc_job_lim$SchoolDegree,
         levels = c("Ph.D.",
                    "professional degree (MBA, MD, JD, etc.)",
                    "master's degree (non-professional)",
                    "bachelor's degree",
                    "associate's degree",
                    "some college credit, no degree",
                    "trade, technical, or vocational training",
                    "high school diploma or equivalent (GED)",
                    "some high school",
                    "no high school (secondary school)"))

g_degree_job_int <- 
  grid.arrange(nice_seg_bar_plot(select(fcc_job_lim, JobRoleInterest, SchoolDegree),
                               "JobRoleInterest", "SchoolDegree",
                               "What is the highest level of school you have completed?\nWhich one of these roles are you most interested in?",
                               c(290, 650)))
```

Mobile developers are indeed the youngest with a first quartile of 20 years, two years younger than the next youngest discipline. The remaining disciplines are fairly close in age, with front-end development being the oldest with a mean age of 29 years.

```{r Age_Job_Role_Interest, fig.width = 8}
# Age by Job Role Interest
g_age_job_int <-
  grid.arrange(nice_boxplot(select(fcc_job_lim, JobRoleInterest, Age),
                            "JobRoleInterest", "Age",
                            "How old are you?\nWhich one of these roles are you most interested in?",
                            c(290, 330)))
with(fcc_job_lim, by(Age, JobRoleInterest, summary))
```

<br>
Data scientists-, data engineers-, and back-end developers-in-training have programmed the longest with a median experience of 8 months. UX designers have the lowest first quartile by two whole months at two months of programming experience.

```{r Years_Prog_Job_Role_Interest, fig.width = 8, fig.height = 7.5}
# Years Programming by Job Role Interest
years_prog_job_lim <- select(fcc_job_lim, JobRoleInterest, MonthsProgramming)
years_prog_job_lim$MonthsProgramming <- years_prog_job_lim$MonthsProgramming / 12
g_months_prog_job_int <-
  grid.arrange(nice_boxplot(years_prog_job_lim,
                            "JobRoleInterest", "YearsProgramming",
                            "About how many years have you been programming for?\nWhich one of these roles are you most interested in?",
                            c(290, 330)))
with(years_prog_job_lim, by(MonthsProgramming, JobRoleInterest, summary))
```

<br>
Full-stack developers dedicate the most time to learning each week, with 25% of respondents dedicating 30+ hours weekly. UX designers spend the least amount of time learning per week with a mean of 12 hours per week.

```{r Hours_Learn_Job_Role_Interest, fig.width = 8}
# Hours Learning by Job Role Interest
g_hours_learn_job_int <-
  grid.arrange(nice_boxplot(select(fcc_job_lim, JobRoleInterest, HoursLearning),
                            "JobRoleInterest", "HoursLearning",
                            "About how many hours do you spend learning each week?\nWhich one of these roles are you most interested in?",
                            c(290, 330)))
with(fcc_job_lim, by(HoursLearning, JobRoleInterest, summary))
```

<br>
Respondents interested in data science and/or engineering clearly have the highest current salaries. Their third quartile of $60k per year is $8k higher than the next highest discipline. There isn't much income differentiation between the remaining job roles of interest.

```{r Income_Job_Role_Interest, fig.width = 8}
# Income by Job Role Interest
g_income_job_int <-
  grid.arrange(nice_boxplot(select(fcc_job_lim, JobRoleInterest, Income),
                            "JobRoleInterest", "Income",
                            "What is your current salary in USD?\nWhich one of these roles are you most interested in?",
                            c(290, 330)))
with(fcc_job_lim, by(Income, JobRoleInterest, summary))
```

<br>
Respondents interested in data science/engineering expect to earn the most at their next job. Given the aforementioned correlation between current salaries and expected salaries, this is not a surprise. Note that expected salaries are higher than current salaries (see the previous boxplot) across the board.

```{r Exp_Earn_Job_Role_Interest, fig.width = 8}
# Expected Earning by Job Role Interest
g_exp_earn_job_int <-
  grid.arrange(nice_boxplot(select(fcc_job_lim, JobRoleInterest, ExpectedEarning),
                            "JobRoleInterest", "ExpectedEarning",
                            "About how much do you expect to earn per year at your first new job in USD?\nWhich one of these roles are you most interested in?",
                            c(290, 330)))
with(fcc_job_lim, by(ExpectedEarning, JobRoleInterest, summary))
```

## Bivariate Analysis

### How did the feature(s) of interest vary with other features in the dataset?

The data science/engineering subset of the survey is largely similar to the non-data science/engineering subset, except for three correlations involving  student debt owed. The skew towards post-secondary studies for the data-focused subset is the likely culprit.

The correlation between current salary and age is stronger than expected next salary and age for the respondent's first data science/engineering job and age.

Hours dedicated to learning per week doesn't appear to vary much with gender or continent, though sample size issues exist.

Expected salary for a respondent's next job varies strongly by continent. Females also appear to have a much higher bottom line for expected salary than males. Those who dedicate more than 40 hours a week to learning expect higher salaries as well.

The majority of respondents for all job roles of interest are male, North American, and have bachelor's degrees. Age, programming experience, hours dedicated to learning, current salary, and expected next salary all vary depending on job role of interest. One or two of the disciplines stands out from the pack for each of the five quantitative variables.

### What was the strongest relationship you found?

No exceedingly strong relationship exists. All correlations are below 0.4.

Current salary and expected next salary has the strongest relationship for both subsets with correlations of 0.36 and 0.38.

### Of the features you investigated, were there any unusual distributions?

Europe’s 75th percentile for expected next salary is North America’s 25th percentile ($50k USD). Perhaps some European respondents forgot to convert from pounds or euros to US dollars.

------

## Multivariate Plots

Let's dig deeper into the strongest correlation: current salary versus expected next salary. Again, this new job is presumably where the respondent will put their new coding skills to use.

Plotting income vs. expected earning across genders, the first impression is that there are a lot of male data points. This abundance makes it hard to tell if the wage gap presents itself in this dataset. Looking at each gender's presence above the $50k lines, my first instinct is that the gap exists. Males definitely have the highest proportion of $150k+ salaries. Stay tuned for the final plots section, where I'll determine the presence of the gap definitively.

```{r Exp_Earn_Income_Gender, fig.height = 6.5}
nice_scatter_mv <- function(df, xlab, ylab, flab, hline, vline, questions, hue) {
  colnames(df)[1] <- "x"
  colnames(df)[2] <- "y"
  colnames(df)[3] <- "f"
  
  df_na_rm <- with(df, df[!is.na(x) & !is.na(y) & !is.na(f), ])
  colnames(df_na_rm)[1] <- "x"
  colnames(df_na_rm)[2] <- "y"
  colnames(df)[3] <- "f"
  
  plot <- ggplot(aes(x = x / 1000, y = y / 1000),
       data = df_na_rm) +
  geom_jitter(aes(colour = f), alpha = 0.75) +
  geom_hline(yintercept = hline, colour = "#454545") +
  geom_vline(xintercept = vline, colour = "#454545") +
  theme_minimal() +
  scale_colour_discrete(h = hue) +
  labs(title = "", x = paste("\n", xlab), y = paste(ylab, "\n"), colour = flab) +
  theme(axis.text = element_text(size = 10, color = "#454545"),
        axis.title = element_text(color = "#454545"))
  
  title.grob <- plot_title(questions)
  plot <- arrangeGrob(plot, top = title.grob)
  return(plot)
}

# Expected Earning by Income by Gender
fcc$Gender <-
  factor(fcc$Gender,
         levels = c("male", "agender", "genderqueer", "trans", "female"))

g_exp_earn_income_gender <-
  grid.arrange(nice_scatter_mv(select(fcc, Income,
                                         ExpectedEarning, Gender),
                               "Income (k)",
                               "ExpectedEarning (k)",
                               "Gender",
                               50, 50,
                               "About how much do you expect to earn per year at your first new job in USD?\nWhat is your current salary in USD?\nWhat is your gender?",
                               c(0, 225)))
```

The same multivariate plot is generated below, but for the question "Are you an ethnic minority in your country?" Again, it is difficult to determine definitively if a wage gap is present. Non-ethnic minorities definitely have a higher proportion of $150k+ salaries, but a huge amount of data points are clustered in the bottom left quadrant. It looks like minorities are better represented above the $50k expected salary line, but not as much for the $50k current salary line. We'll see for sure if this is indeed true in the final plots section.

```{r Exp_Earn_Income_Ethnicity, fig.height = 6.5}
# Expected Earning by Income by EthnicMinority
fcc$IsEthnicMinority <- order_factor(fcc$IsEthnicMinority, "desc")
g_exp_earn_income_em <-
  grid.arrange(nice_scatter_mv(select(fcc, Income, ExpectedEarning,
                                         IsEthnicMinority),
                               "Income (k)",
                               "ExpectedEarning (k)",
                               "IsEthnicMinority",
                               50, 50,
                               "About how much do you expect to earn per year at your first new job in USD?\nWhat is your current salary in USD?\nAre you an ethnic minority in your country?",
                               c(0, 150)))
```

Let's combine all of the purple/pink boxplots from the bivariate plots section into one [radar chart](https://en.wikipedia.org/wiki/Radar_chart). The mean for each numerical variable normalized between 0 and 1 is plotted for each job role of interest.

One thing jumps out immediately: developing data scientists/engineers lead the pack for programming experience, current salary, and expected next salary. Beyond that, however, overplotting is again an issue, which makes it difficult to internalize other patterns in the data. I'll fix that for all three multivariate plots in the final plots section.

```{r Radar_Job_Role_Interest, fig.height = 6.5}
# Means for each JobRoleInterest five numerical variables
mean_table <-
  fcc_job_lim %>%
  group_by(JobRoleInterest) %>%
  summarise(HoursLearning = mean(HoursLearning, na.rm = TRUE),
            Income = mean(Income, na.rm = TRUE),
            ExpectedEarning = mean(ExpectedEarning, na.rm = TRUE),
            Age = mean(Age, na.rm = TRUE),
            YearsProgramming = mean(MonthsProgramming / 12, na.rm = TRUE)) %>%
  na.omit()

# Drop factor variable (JobRoleInterest) to perform normalization
col_hourslearning = 2
col_yearsprogramming = 6
mean_table <- mean_table[ , col_hourslearning:col_yearsprogramming]

# Normalize between 0 and 1
mean_table_scaled <- as.data.frame(lapply(mean_table, ggplot2:::rescale01))

# Add factor variable
mean_table_scaled$JobRoleInterest <-
  c("Full-Stack Developer", "Front-End Developer",
    "Back-End Developer", "Data Scientist / Engineer",
    "Mobile Developer", "UX Designer")
mean_table_scaled$JobRoleInterest <- factor(mean_table_scaled$JobRoleInterest)
mean_table_scaled$JobRoleInterest <-
  factor(mean_table_scaled$JobRoleInterest,
         levels = c("Full-Stack Developer", "Front-End Developer",
                    "Back-End Developer", "Data Scientist / Engineer",
                    "Mobile Developer", "UX Designer"))

# Convert to long format for radar chart
mean_table_long <- reshape2::melt(mean_table_scaled)

# Radar coordinates
coord_radar <- function (theta = "x", start = 0, direction = 1) 
{
  theta <- match.arg(theta, c("x", "y"))
  r <- if (theta == "x") 
    "y"
  else "x"
  ggproto("CordRadar", CoordPolar, theta = theta, r = r, start = start, 
          direction = sign(direction),
          is_linear = function(coord) TRUE)
}

# Radar chart
g_radar_job_int <-
  ggplot(mean_table_long, aes(x = variable, y = value)) +
  geom_polygon(aes(group = JobRoleInterest, color = JobRoleInterest),
               fill = NA, size = 1, show.legend = FALSE) +
  geom_line(aes(group = JobRoleInterest, color = JobRoleInterest), size = 1) +
  #labs(title = "") +
  theme_minimal() +
  theme(text = element_text(color="#454545"),
        title = element_text(color = "#454545"),
        axis.text.x = element_text(size = rel(0.8)),
        axis.ticks.y = element_blank(),
        axis.text.y = element_blank(),
        axis.title.x = element_blank()) +
  xlab("") + ylab("Normalized mean ([0,1])") +
  guides(color = guide_legend(ncol=1)) +
  coord_radar()

# Radar chart title
g_radar_job_int.grob <-
  plot_title("About how many years have you been programming for?\nAbout how many hours do you spend learning each week?\nWhat is your current salary in USD?\nAbout how much do you expect to earn per year at your first new job in USD?\nHow old are you?\nWhich one of these roles are you most interested in?")
g_radar_job_int <- arrangeGrob(g_radar_job_int, top = g_radar_job_int.grob)
grid.arrange(g_radar_job_int)
```

## Multivariate Analysis

### Were there any interesting or surprising interactions between features?
Males and ethnic majorities dominate the $150k+ salary range, but an overall wage gap between genders and ethnicities for this dataset is not definitive when all the data points are plotted together. I thought the gaps would instantly be clear. More exploration needs to be done, and more will be done in the next section.

------

## Final Plots

### Plot One

```{r Final_Plot_1, fig.height = 7}
nice_scatter_mv_facet <- function(df, xlab, ylab, flab, hline, vline, questions, hue) {
  colnames(df)[1] <- "x"
  colnames(df)[2] <- "y"
  colnames(df)[3] <- "f"
  
  df_na_rm <- with(df, df[!is.na(x) & !is.na(y) & !is.na(f), ])
  colnames(df_na_rm)[1] <- "x"
  colnames(df_na_rm)[2] <- "y"
  colnames(df)[3] <- "f"
  
  plot <- ggplot(aes(x = x / 1000, y = y / 1000),
       data = df_na_rm) +
    geom_jitter(aes(colour = f), alpha = 0.75) +
    stat_density2d(aes(alpha=..level..), geom="polygon") +
    geom_hline(yintercept = hline, colour = "#454545") +
    geom_vline(xintercept = vline, colour = "#454545") +
    theme_minimal() +
    facet_wrap(~ f) +
    scale_colour_discrete(h = hue) +
    labs(title = "", x = paste("\n", xlab), y = paste(ylab, "\n"), colour = flab) +
    theme(axis.text = element_text(size = 10, color = "#454545"),
          axis.title = element_text(color = "#454545"),
          legend.position = "none")
  
  title.grob <- plot_title(questions)
  plot <- arrangeGrob(plot, top = title.grob)
  return(plot)
}

exp_earn_income_gender_mf <-
  filter(select(fcc, Income, ExpectedEarning, Gender),
         Gender == "male" | Gender == "female")
g_exp_earn_income_g_em <-
  grid.arrange(nice_scatter_mv_facet(exp_earn_income_gender_mf,
                                     "Income (k)",
                                     "ExpectedEarning (k)",
                                     "Gender",
                                     50, 50,
                                     "About how much do you expect to earn per year at your first new job in USD?\nWhat is your current salary in USD?\nWhat is your gender?",
                                     c(0, 225)),
               nice_scatter_mv_facet(select(fcc, Income, ExpectedEarning,
                                            IsEthnicMinority),
                                     "Income (k)",
                                     "ExpectedEarning (k)",
                                     "IsEthnicMinority",
                                     50, 50,
                                     "About how much do you expect to earn per year at your first new job in USD?\nWhat is your current salary in USD?\nAre you an ethnic minority in your country?",
                                     c(0, 150)))
```

### Description One

For males vs. females, the density overlay tells us that the wage gap, i.e. males earn more than females, actually does **not** exist in this dataset. Though males do have the highest proportion of elite ($150k+) current and expected next salaries, it appears that a similar proportion of males and females are in the top right quadrant above both $50k lines. Females expect higher next salaries, while current salaries are similar.

An ethnicity-based wage gap does not exist as well, based on the density overlay for the second plot. Current salary densities are nearly identical. Ethnic minorities appear optimistic about the changing diversity landscape via their notable presence in the top left quadrant. This quadrant is where current salaries are below $50k, but expected next salaries are above $50k.

Higher dispersion exists for the majority demographic in both cases, with notable densities near the origin. The relationship between expected and current salary is much stronger for the minority demographic.

Perhaps new coders aren't reflective of the working population in general, where data suggests that [a racial and gender wage gap](http://www.pewresearch.org/fact-tank/2016/07/01/racial-gender-wage-gaps-persist-in-u-s-despite-some-progress/) still exists in 2016.

### Plot Two

```{r Final_Plot_2, fig.height = 7, fig.width = 7.2}
g_gender_cont_job_int <- grid.arrange(g_gender_job_int, g_cont_job_int)
```

### Description Two

The dataset's two main categorical variables - gender and citizenship by continent - convey the basic demographics of each job role of interest.

The majority of survey respondents are males and North Americans. Mobile development has the highest percentage of males. User experience design has the highest percentage of North Americans.

User experience designer is the most diverse role in terms of gender, with about the same amount of males as females and the highest percentage of agender, genderqueer, and trans respondents.

Mobile developer is the most diverse role in terms of citizenship, with the lowest percentage of North Americans and relatively high percentages of Asians, South Americans, and Africans.

### Plot Three

```{r Final_Plot_3, fig.height = 7.2}
g_radar_job_int_facet <-
  ggplot(mean_table_long, aes(x = variable, y = value)) +
  geom_polygon(aes(group = JobRoleInterest, color = JobRoleInterest),
               fill = NA, size = 1) +
  theme_minimal() +
  labs(title = "") +
  facet_wrap(~ JobRoleInterest) +
  theme(text = element_text(color="#454545"),
        title = element_text(color = "#454545"),
        axis.ticks = element_blank(),
        axis.text.x = element_text(size = rel(0.70), colour = "#454545"),
        axis.text.y = element_blank(),
        axis.title.x = element_blank(),
        panel.margin.y = unit(2, "lines")) +
  # plot.margin = unit(c(0.4,0.65,0,0), "cm")
  xlab("") + ylab("Normalized mean ([0,1])") +
  guides(color = "none") +
  coord_radar()

g_radar_job_int_facet <- arrangeGrob(g_radar_job_int_facet, top = g_radar_job_int.grob)
grid.arrange(g_radar_job_int_facet)
```

### Description Three

This faceted radar chart, where the normalized mean (between 0 and 1) for each numerical variable is plotted for each job role of interest, clarifies the differences between disciplines.

Developing data scientists/engineers make the most money, expect the most money for their next job, and have the most programming experience. They have the largest amount of area within their polygon.

Full-stack developers are relatively older and dedicate the most amount of time to learning weekly. They also have a large polygon area.

Front-end developers are green in terms of programming experience and have the lowest salary expectations for their first job where they advertise their new web development skills. They also have relatively low current salaries. These three factors contribute to the smallest polygon area.

Mobile developers are the youngest and currently do not make much money. These characteristics are expected of the discipline with the highest proportion of respondents with no, some, or only a high school education. They have the second smallest polygon area.

------

## Summary

Developing data scientists and engineers are slightly different than new coders in general.

- They have programmed for longer.
- They want to work for developed companies, rather than freelance or create their own.
- They have a longer job search time horizon.
- They use Coursera, edX, and Udacity more frequently.
- They use bootcamps less frequently.
- They have completed higher levels of education.
- They come from a wider subject area background.
- Fewer are currently working.
- Fewer work in the tech industry.
- They have more student debt.

The two datasets do share plenty of common trends. Demographics are similar. Most are willing to relocate. Most don't use podcasts or attend events yet.

Older new coders are willing to take a pay cut when transitioning to a job where they advertise their new coding skills. Younger new coders intend to increase their earning potential by capitalizing on demand for coding.

Weekly hours dedicated to learning doesn't differ much across genders and citizenships by continent. Next expected salary does, however. Most people aren't replacing the traditional college/university route with full-time online education...yet. Those that are expect higher salaries.

Gender and continent distributions across job roles of interest vary. Females appear drawn to user experience design. Asians, South Americans, and Africans appear drawn to mobile development. School degree obtained does not vary much by discipline overall, though data science/engineering and mobile development stick out as the most and least seasoned in terms of education, respectively.

Developing data/scientists have the highest current salaries, expect the highest next salaries, and have the most programming experience. Front-end developers are the oldest. Full-stack developers dedicate the most amount of time to learning per week.

Mobile developers are the youngest and have the lowest current salaries. Front-end developers are the least experienced coders and expect the lowest next salaries. UX designers spend the least amount of hours learning weekly.

The gender and racial wage gaps do not present themselves in this dataset. Perhaps new coders aren’t reflective of the working population in general.

## Reflection

The successes of this exploration are largely due to the detailed design of the Free Code Camp survey.

The main struggle I encountered in this exploration was the lack of a main feature of interest, like the diamond dataset's price variable. It would be awesome if we could survey the same respondents in a decade or so. We could combine career earnings and career satisfaction with the 2016 survey's results to build a predictive model to estimate career success.

These are the people who are learning data science and engineering. It is clear that free, self-paced learning resources are important.